<?php
/**
 * Hanldes assignment of template variables and generation of output upon call by the controller.
 * 
 * @package core
 */
namespace component;
class View
{	
	/**
	 * Holds all variable assignments supplied to the template. 
	 * These are set/fetched/destroyed via the magical methods built in
	 * with PHP classes.
	 */
	protected $_data = array();
	
	/**
	 * Maintains global variables assigned from any namespace and applied to all templates.
	 * These are applied before template variables, so they may be overloaded via $this->$_data
	 * on a per-view basis.
	 */
	public static $globals = array();
	
	/**
	 * Template to be loaded and output
	 */
	protected $template;
    
	/**
   * The adapterType to use for generating view output.
   * @var type 
   */
  protected $adapterType;
  
  /**
   * Where to search for view templates.
   * @var type 
   */
  protected $templateDirectory = 'template';
  
	/**
   * Constructor. 
   * @param type $template The path to the template file to load
   * @param type $outputType The generated output type.
   */
	public function __construct($template, $outputType = 'html')
	{
		$this->template = $template;
    $this->setAdapterType($outputType);
	}
  
  /**
   * Set the view adapterType.
   * @param type $adapterType
   */
  public function setAdapterType($adapterType)
  {
    $this->adapterType = $adapterType;
  }
	
	/**
	 * Assigns any template variable to $this->data array
	 * 
	 * @param mixed $name
	 * @param mixed $value
	 */
	public function __set($name, $value)
	{
		$this->_data[$name] = $value;
	}
	
	/**
	 * Set a global variable to be applied to all templates.
	 * Globals may also be set directly via self::$globals.
	 * 
	 * @param
	 * @return
	 */
	public static function set_global($name, $value)
	{
		self::$globals[$name] = $value;
	}
	
	/**
	 * Fetches value of supplied template variable from $this->data 
	 * array
	 * 
	 * @param $name
	 * @return mixed
	 */
	public function __get($name)
	{
		if (isset($this->_data[$name]))
		{
			return $this->_data[$name];
		}
	}
	
	/**
	 * Returns whether specified template variable has a value
	 *
	 * @param $name
	 * @return bool
	 */
	public function __isset($name)
	{
		return (bool) array_key_exists($name, $this->_data);
	}
	
  /**
   * Unset the specified template variable.
   * @param type $name
   */
	public function __unset($name)
	{
		unset($this->_data[$name]);
	}
	
	/**
	 * Generates template output.
	 * Extracts $this->_data into local namespace so that it can be
	 * interpolated into the output generated by template.
	 *
	 * @return bool
	 * @throws \Exception
	 */
	public function display()
	{
		// Build the Adapter class path.
    $className = '\\component\\adapter\\view\\' . ucfirst(strtolower($this->adapterType));
    if ( ! class_exists($className))
    {
      throw new \Exception(
        "Unsupported display type '{$this->adapterType}'." 
        . " Create a custom adapter in '/component/adapter/view/' to enable support."
      );
    }
    
    // Build adapter intput.
    $input = array(
      'template' => $this->template,
      'templateDirectory' => $this->templateDirectory,
      'globals' => self::$globals,
      'data' => $this->_data
    );
    
    // Build adapter and generate output.
    $adapter = new $className($input);
    $adapter->getOutput();
    
		return TRUE;
	}
	
	/**
	 * Returns template output so that it may be assigned to a variable
	 * rather than displayed directly. This is useful when you want to
	 * embed template content inside another template.
	 *
	 * @return string
	 */
	public function fetch()
	{		
		ob_start();		
		$this->display();
		$content = ob_get_clean();
		return $content;
	}
}
